
================================================
File: src/the_aichemist_codex/backend/output_formatter/__init__.py
================================================
"""Output handling module for different file formats."""

from .csv_writer import save_as_csv
from .html_writer import save_as_html
from .json_writer import save_as_json, save_as_json_async
from .markdown_writer import save_as_markdown

__all__ = [
    "save_as_csv",
    "save_as_html",
    "save_as_json",
    "save_as_json_async",
    "save_as_markdown",
]



================================================
File: src/the_aichemist_codex/backend/output_formatter/csv_writer.py
================================================
import csv
import io
import logging
from pathlib import Path

from the_aichemist_codex.backend.utils.async_io import (
    AsyncFileIO,
)  # Adjust import as needed

logger = logging.getLogger(__name__)


async def save_as_csv(output_file: Path, data: dict) -> bool:
    """Asynchronously saves extracted code summary as a CSV file."""
    try:
        # Create CSV content in memory using StringIO.
        csv_buffer = io.StringIO()
        writer = csv.writer(csv_buffer)
        writer.writerow(["File", "Type", "Name", "Arguments", "Line Number"])
        for file, functions in data.items():
            for func in functions:
                writer.writerow(
                    [
                        file,
                        func["type"],
                        func["name"],
                        ", ".join(func.get("args", [])),
                        func["lineno"],
                    ]
                )
        csv_content = csv_buffer.getvalue()

        # Write CSV content asynchronously.
        success = await AsyncFileIO.write(output_file, csv_content)
        if success:
            logger.info(f"CSV summary saved: {output_file}")
        else:
            logger.error(f"Error writing CSV output to {output_file}")
        return success

    except Exception as e:
        logger.error(f"Error writing CSV output to {output_file}: {e}")
        return False



================================================
File: src/the_aichemist_codex/backend/output_formatter/html_writer.py
================================================
import logging
from pathlib import Path

from the_aichemist_codex.backend.utils.async_io import (
    AsyncFileIO,
)  # Adjust import as needed

logger = logging.getLogger(__name__)


async def save_as_html(
    output_file: Path, data: dict, title="Project Code Summary"
) -> bool:
    """Asynchronously saves extracted code summary as an HTML report."""
    try:
        html_content = f"<html><head><title>{title}</title></head><body>"
        html_content += f"<h1>{title}</h1>"

        for file, functions in data.items():
            if not functions:
                continue
            html_content += f"<h2>{file}</h2>"
            # If a summary exists in data for the file, include it; otherwise a default message.
            html_content += (
                f"<p><b>Summary:</b> {data.get(file, 'No summary available.')}</p>"
            )

            html_content += "<ul>"
            for func in functions:
                html_content += f"<li><b>{func['type'].capitalize()}</b>: {func['name']} (Line {func['lineno']})"
                if func.get("args"):
                    html_content += f" | Arguments: {', '.join(func['args'])}"
                html_content += "</li>"
            html_content += "</ul>"

        html_content += "</body></html>"

        success = await AsyncFileIO.write(output_file, html_content)
        if success:
            logger.info(f"HTML summary saved: {output_file}")
        else:
            logger.error(f"Error writing HTML output to {output_file}")
        return success

    except Exception as e:
        logger.error(f"Error writing HTML output to {output_file}: {e}")
        return False



================================================
File: src/the_aichemist_codex/backend/output_formatter/json_writer.py
================================================
"""Handles JSON output for structured code summaries."""

import json
import logging
from pathlib import Path

import aiofiles

logger = logging.getLogger(__name__)


class PathEncoder(json.JSONEncoder):
    def default(self, obj):
        if isinstance(obj, Path):
            return str(obj)
        return super().default(obj)


async def save_as_json_async(data, output_file: Path):
    """Saves data as JSON asynchronously, converting Path objects to strings."""
    try:
        json_data = json.dumps(data, cls=PathEncoder, indent=4)
        async with aiofiles.open(output_file, "w", encoding="utf-8") as f:
            await f.write(json_data)
        logger.info(f"File tree saved to {output_file}")
    except Exception as e:
        logger.error(f"Error writing JSON to {output_file}: {e}")


def save_as_json(output_file: Path, data: dict):
    """Saves extracted code summary as a structured JSON file."""
    import asyncio

    return asyncio.run(save_as_json_async(data, output_file))



================================================
File: src/the_aichemist_codex/backend/output_formatter/markdown_writer.py
================================================
import logging
from pathlib import Path

from the_aichemist_codex.backend.utils.async_io import (
    AsyncFileIO,
)  # Adjust import as needed

logger = logging.getLogger(__name__)


async def save_as_markdown(
    output_file: Path, data: dict, gpt_summaries=None, title="Project Code Summary"
) -> bool:
    """Asynchronously saves extracted code summary in a Markdown format."""
    if gpt_summaries is None:
        gpt_summaries = {}

    try:
        markdown_content = f"# ðŸ“– {title}\n\n"
        markdown_content += (
            "This document provides an AI-optimized summary of the project, including file organization, "
            "summaries, and function breakdowns.\n\n"
        )
        markdown_content += "---\n\n"

        if not data:
            markdown_content += (
                "No files were analyzed. Check for errors in `code_summary.json`.\n"
            )
        else:
            # Group files by folder.
            folder_map = {}
            for file, details in data.items():
                folder = details.get("folder", "Other")
                folder_map.setdefault(folder, []).append((file, details))

            for folder, files in sorted(folder_map.items()):
                markdown_content += f"## ðŸ“‚ Folder: `{folder}/`\n"
                for file, details in sorted(files):
                    markdown_content += f"### ðŸ“„ `{file}`\n"
                    markdown_content += f"**Summary:** {details.get('summary', 'No summary available.')}\n\n"

                    if not details.get("functions"):
                        markdown_content += (
                            "**No functions detected in this file.**\n\n"
                        )
                    else:
                        markdown_content += f"#### Functions in `{file}`:\n"
                        for func in details["functions"]:
                            func_name = func.get("name", "Unnamed Function")
                            func_args = (
                                ", ".join(func.get("args", []))
                                if func.get("args")
                                else "None"
                            )
                            func_lineno = func.get("lineno", "Unknown")
                            func_docstring = func.get(
                                "docstring", "No docstring provided."
                            )
                            markdown_content += f"##### ðŸ”¹ `{func_name}({func_args})`\n"
                            markdown_content += (
                                f"- **Defined at:** Line {func_lineno}\n"
                            )
                            markdown_content += f"- **Docstring:** {func_docstring}\n\n"
                    markdown_content += "\n---\n\n"

        success = await AsyncFileIO.write(output_file, markdown_content)
        if success:
            logger.info(f"Markdown summary saved: {output_file}")
        else:
            logger.error(f"Error writing Markdown output to {output_file}")
        return success

    except Exception as e:
        logger.error(f"Error writing Markdown output to {output_file}: {e}")
        return False

