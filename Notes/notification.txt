
================================================
File: src/the_aichemist_codex/backend/notification/__init__.py
================================================
"""Notification system for The Aichemist Codex."""

from the_aichemist_codex.backend.notification.notification_manager import (
    Notification,
    NotificationLevel,
    NotificationManager,
    NotificationType,
    notification_manager,
)

# Import rule engine components if available
try:
    from the_aichemist_codex.backend.notification.rule_engine import (
        ActionType,
        ConditionOperator,
        NotificationRule,
        RuleAction,
        RuleCondition,
        TimeCondition,
        TimeConditionType,
        rule_engine,
    )

    __all__ = [
        "Notification",
        "NotificationLevel",
        "NotificationType",
        "NotificationManager",
        "notification_manager",
        "NotificationRule",
        "RuleCondition",
        "RuleAction",
        "TimeCondition",
        "ConditionOperator",
        "TimeConditionType",
        "ActionType",
        "rule_engine",
    ]
except ImportError:
    # Rule engine not available
    __all__ = [
        "Notification",
        "NotificationLevel",
        "NotificationType",
        "NotificationManager",
        "notification_manager",
    ]



================================================
File: src/the_aichemist_codex/backend/notification/email_subscriber.py
================================================
"""Email subscriber for the notification system."""

import asyncio
import logging
import smtplib
from datetime import datetime
from email.message import EmailMessage
from email.utils import formatdate
from typing import Any

from the_aichemist_codex.backend.notification.notification_manager import (
    Notification,
    NotificationSubscriber,
)

logger = logging.getLogger(__name__)


class EmailSubscriber(NotificationSubscriber):
    """Subscriber that sends notifications via email."""

    def __init__(self, name: str, settings: dict[str, Any] | None = None):
        """
        Initialize the email subscriber.

        Args:
            name: Name of the subscriber
            settings: Subscriber-specific settings including:
                - smtp_server: SMTP server address
                - smtp_port: SMTP server port
                - use_tls: Whether to use TLS encryption
                - username: SMTP username for authentication
                - password: SMTP password for authentication
                - from_address: Sender email address
                - to_addresses: List of recipient email addresses
                - subject_prefix: Prefix for email subjects
                - batch_mode: Whether to send emails in batches
                - batch_interval: Seconds between batch sends
                - max_batch_size: Maximum number of notifications in a batch
        """
        super().__init__(name, settings)

        # Extract email-specific settings
        self.smtp_server = self.settings.get("smtp_server", "localhost")
        self.smtp_port = self.settings.get("smtp_port", 25)
        self.use_tls = self.settings.get("use_tls", False)
        self.username = self.settings.get("username")
        self.password = self.settings.get("password")
        self.from_address = self.settings.get("from_address", "codex@example.com")
        self.to_addresses = self.settings.get("to_addresses", [])
        self.subject_prefix = self.settings.get("subject_prefix", "[AIchemist Codex] ")

        # Batch mode settings
        self.batch_mode = self.settings.get("batch_mode", False)
        self.batch_interval = self.settings.get("batch_interval", 300)  # 5 minutes
        self.max_batch_size = self.settings.get("max_batch_size", 20)

        # Initialize batch queue if in batch mode
        self.batch_queue: list[Notification] = []
        self._batch_task = None

        # Validate required settings
        if not self.to_addresses:
            logger.warning("EmailSubscriber initialized with no recipient addresses")
            self.enabled = False

        # Start batch sending task if enabled
        if self.enabled and self.batch_mode:
            self._start_batch_task()

    def _start_batch_task(self):
        """Start the background task for batch email sending."""
        if self._batch_task is None:
            self._batch_task = asyncio.create_task(self._batch_send_loop())
            logger.debug("Started email batch sending task")

    async def _batch_send_loop(self):
        """Background task that sends batched emails periodically."""
        try:
            while True:
                await asyncio.sleep(self.batch_interval)

                # Check if we have any notifications to send
                if self.batch_queue:
                    notifications = self.batch_queue.copy()
                    self.batch_queue = []

                    # Send the batch
                    await self._send_batch_email(notifications)
        except asyncio.CancelledError:
            logger.debug("Email batch sending task cancelled")
        except Exception as e:
            logger.error(f"Error in email batch sending task: {e}")

    async def _process_notification(self, notification: Notification) -> bool:
        """
        Process notification by sending an email or adding to batch.

        Args:
            notification: The notification to process

        Returns:
            True if notification was processed successfully
        """
        # If in batch mode, add to queue and return
        if self.batch_mode:
            self.batch_queue.append(notification)

            # If queue is getting too large, send immediately
            if len(self.batch_queue) >= self.max_batch_size:
                notifications = self.batch_queue.copy()
                self.batch_queue = []
                return await self._send_batch_email(notifications)

            return True

        # Otherwise, send immediately
        return await self._send_single_email(notification)

    async def _send_single_email(self, notification: Notification) -> bool:
        """
        Send a single notification as an email.

        Args:
            notification: The notification to send

        Returns:
            True if the email was sent successfully
        """
        # Create email message
        msg = EmailMessage()
        msg["From"] = self.from_address
        msg["To"] = ", ".join(self.to_addresses)
        msg["Date"] = formatdate(localtime=True)

        # Create subject based on notification level and type
        subject = f"{self.subject_prefix}{notification.level.name}: {notification.notification_type.value.capitalize()}"
        if notification.source:
            subject = f"{subject} - {notification.source}"
        msg["Subject"] = subject

        # Create email body
        body = [f"Message: {notification.message}"]

        # Add timestamp
        timestamp = datetime.fromtimestamp(notification.timestamp).strftime(
            "%Y-%m-%d %H:%M:%S"
        )
        body.append(f"\nTimestamp: {timestamp}")

        # Add details if present
        if notification.details:
            body.append("\nDetails:")
            for key, value in notification.details.items():
                body.append(f"  {key}: {value}")

        # Set message content
        msg.set_content("\n".join(body))

        # Send the email
        return await self._send_email_message(msg)

    async def _send_batch_email(self, notifications: list[Notification]) -> bool:
        """
        Send multiple notifications in a single email.

        Args:
            notifications: List of notifications to send

        Returns:
            True if the email was sent successfully
        """
        if not notifications:
            return True

        # Create email message
        msg = EmailMessage()
        msg["From"] = self.from_address
        msg["To"] = ", ".join(self.to_addresses)
        msg["Date"] = formatdate(localtime=True)

        # Create subject based on batch size and highest level
        highest_level = max(n.level for n in notifications)
        count = len(notifications)
        msg["Subject"] = (
            f"{self.subject_prefix}{highest_level.name}: {count} New Notifications"
        )

        # Create email body
        body = [f"The Aichemist Codex has {count} new notifications:"]
        body.append("")

        # Group notifications by type
        grouped: dict[str, list[Notification]] = {}
        for notification in notifications:
            notification_type = notification.notification_type.value
            if notification_type not in grouped:
                grouped[notification_type] = []
            grouped[notification_type].append(notification)

        # Add each group to the email
        for notification_type, group in grouped.items():
            body.append(
                f"## {notification_type.capitalize()} Notifications ({len(group)}):"
            )
            body.append("")

            for i, notification in enumerate(
                sorted(group, key=lambda n: n.level.value, reverse=True), 1
            ):
                timestamp = datetime.fromtimestamp(notification.timestamp).strftime(
                    "%Y-%m-%d %H:%M:%S"
                )
                body.append(f"{i}. [{notification.level.name}] {notification.message}")
                body.append(f"   Time: {timestamp}")
                if notification.source:
                    body.append(f"   Source: {notification.source}")
                if notification.details:
                    body.append(f"   Details: {notification.details}")
                body.append("")

        # Set message content
        msg.set_content("\n".join(body))

        # Send the email
        return await self._send_email_message(msg)

    async def _send_email_message(self, msg: EmailMessage) -> bool:
        """
        Send an email message via SMTP.

        Args:
            msg: The email message to send

        Returns:
            True if the email was sent successfully
        """
        # Run SMTP sending in a thread pool to avoid blocking
        try:
            loop = asyncio.get_running_loop()
            return await loop.run_in_executor(None, self._send_email_sync, msg)
        except Exception as e:
            logger.error(f"Failed to send email: {e}")
            return False

    def _send_email_sync(self, msg: EmailMessage) -> bool:
        """
        Synchronous implementation of email sending.

        Args:
            msg: The email message to send

        Returns:
            True if the email was sent successfully
        """
        try:
            # Connect to SMTP server
            with smtplib.SMTP(self.smtp_server, self.smtp_port) as server:
                # Use TLS if configured
                if self.use_tls:
                    server.starttls()

                # Login if credentials are provided
                if self.username and self.password:
                    server.login(self.username, self.password)

                # Send the email
                server.send_message(msg)

            logger.debug(f"Email sent to {msg['To']}")
            return True
        except smtplib.SMTPException as e:
            logger.error(f"SMTP error sending email: {e}")
            return False
        except Exception as e:
            logger.error(f"Unexpected error sending email: {e}")
            return False



================================================
File: src/the_aichemist_codex/backend/notification/notification_manager.py
================================================
"""
Notification system for managing and delivering notifications.

This module provides a comprehensive notification system with a publisher-subscriber
pattern. It handles creation, storage, and delivery of notifications across the application.
Notifications are categorized by levels (info, warning, error) and types (system, file, task).

The module uses a centralized data directory to store notifications in JSON format.

Typical usage:
    manager = NotificationManager()
    notification = manager.create_notification(
        "File Processed",
        "File example.txt has been processed successfully",
        NotificationLevel.INFO,
        NotificationType.FILE
    )

    # Subscribe to notifications
    def handle_notification(notification):
        print(f"Received: {notification.title}")
"""

import asyncio
import hashlib
import json
import logging
import time
from enum import Enum, auto
from typing import Any

from the_aichemist_codex.backend.config.settings import DATA_DIR, NOTIFICATION_SETTINGS
from the_aichemist_codex.backend.utils.async_io import AsyncFileIO

logger = logging.getLogger(__name__)

# Define notification database path
NOTIFICATION_DB_PATH = DATA_DIR / "notifications.json"

# Ensure notification directory exists
(DATA_DIR / "notifications").mkdir(exist_ok=True, parents=True)

# Define a type variable for SimpleCache
T = TypeVar("T")


class NotificationLevel(Enum):
    """
    Enumeration for notification priority levels.

    Attributes:
        INFO: Low priority informational notifications
        WARNING: Medium priority warning notifications
        ERROR: High priority error notifications
        CRITICAL: Highest priority critical notifications
    """

    INFO = auto()
    WARNING = auto()
    ERROR = auto()
    CRITICAL = auto()

    @classmethod
    def from_string(cls, level_str: str) -> "NotificationLevel":
        """Convert a string level to an enum value."""
        try:
            return cls[level_str.upper()]
        except KeyError:
            logger.warning(f"Invalid notification level: {level_str}, using INFO")
            return cls.INFO

    def __ge__(self, other: "NotificationLevel") -> bool:
        """Compare notification levels for greater than or equal."""
        if self.__class__ is other.__class__:
            return self.value >= other.value
        return NotImplemented

    def __lt__(self, other: "NotificationLevel") -> bool:
        """Compare notification levels for less than."""
        if self.__class__ is other.__class__:
            return self.value < other.value
        return NotImplemented


class NotificationType(Enum):
    """
    Enumeration for notification categories.

    Attributes:
        SYSTEM: System-level notifications related to application functionality
        FILE: File-related notifications for file operations and status
        TASK: Task-related notifications for background job status
        SECURITY: Security-related notifications for access and permissions
        USER: User-related notifications for account and profile updates
    """

    SYSTEM = auto()
    FILE = auto()
    TASK = auto()
    SECURITY = auto()
    USER = auto()


class Notification:
    """
    Represents a single notification with metadata.

    This class encapsulates all notification data including title, message,
    level, type, timestamp, and read status.

    Attributes:
        id: Unique identifier for the notification
        title: Short notification title
        message: Detailed notification message
        level: Priority level (INFO, WARNING, ERROR, CRITICAL)
        type: Category type (SYSTEM, FILE, TASK, etc.)
        timestamp: Creation time of the notification
        read: Whether the notification has been marked as read
        metadata: Additional contextual information for the notification
    """

    def __init__(
        self,
        message: str,
        level: str | NotificationLevel = NotificationLevel.INFO,
        notification_type: str | NotificationType = NotificationType.SYSTEM,
        source: str = "",
        timestamp: float | None = None,
        details: dict[str, Any] | None = None,
        notification_id: str | None = None,
    ) -> None:
        """
        Initialize a notification.

        Args:
            message: The notification message
            level: Severity level
            notification_type: Category of notification
            source: Source of the notification (e.g., component name)
            timestamp: When the notification was created (defaults to now)
            details: Additional structured data
            notification_id: Unique identifier (generated if not provided)
        """
        self.message = message

        # Convert string level to enum if needed
        if isinstance(level, str):
            self.level = NotificationLevel.from_string(level)
        else:
            self.level = level

        # Convert string type to enum if needed
        if isinstance(notification_type, str):
            try:
                self.notification_type = NotificationType(notification_type)
            except ValueError:
                logger.warning(
                    f"Invalid notification type: {notification_type}, using SYSTEM"
                )
                self.notification_type = NotificationType.SYSTEM
        else:
            self.notification_type = notification_type

        self.source = source
        self.timestamp = timestamp or time.time()
        self.details = details or {}

        # Generate ID based on content if not provided
        if notification_id is None:
            content_hash = hashlib.sha256(
                f"{self.message}{self.level.name}{self.notification_type.value}{self.source}{self.timestamp}".encode()
            ).hexdigest()
            self.id = f"{int(self.timestamp)}_{content_hash[:8]}"
        else:
            self.id = notification_id

    def to_dict(self) -> dict[str, Any]:
        """Convert to dictionary for serialization."""
        return {
            "id": self.id,
            "message": self.message,
            "level": self.level.name,
            "type": self.notification_type.value,
            "source": self.source,
            "timestamp": self.timestamp,
            "details": self.details,
        }

    @classmethod
    def from_dict(cls, data: dict[str, Any]) -> "Notification":
        """Create from dictionary (for deserialization)."""
        return cls(
            message=data["message"],
            level=data["level"],
            notification_type=data["type"],
            source=data.get("source", ""),
            timestamp=data["timestamp"],
            details=data.get("details", {}),
            notification_id=data["id"],
        )

    def __str__(self) -> str:
        """Return string representation of notification."""
        return f"[{self.level.name}] {self.message} (from {self.source})"


class NotificationSubscriber:
    """Base class for notification subscribers."""

    def __init__(self, name: str, settings: dict[str, Any] | None = None) -> None:
        """
        Initialize a notification subscriber.

        Args:
            name: Name of the subscriber
            settings: Subscriber-specific settings
        """
        self.name = name
        self.settings = settings or {}  # Convert None to empty dict
        self.min_level = NotificationLevel.from_string(
            self.settings.get("min_level", "INFO")
        )
        self.enabled = self.settings.get("enabled", True)

    async def notify(self, notification: Notification) -> bool:
        """
        Process a notification.

        Args:
            notification: The notification to process

        Returns:
            True if notification was successfully processed
        """
        # Skip if subscriber is disabled or notification level is too low
        if not self.enabled or notification.level < self.min_level:
            return False

        try:
            return await self._process_notification(notification)
        except Exception as e:
            logger.error(f"Error in {self.name} subscriber: {e}")
            return False

    async def _process_notification(self, notification: Notification) -> bool:
        """
        Process a notification (to be implemented by subclasses).

        Args:
            notification: The notification to process

        Returns:
            True if notification was successfully processed
        """
        raise NotImplementedError("Subscribers must implement _process_notification")


class LogSubscriber(NotificationSubscriber):
    """Subscriber that logs notifications to the application log."""

    async def _process_notification(self, notification: Notification) -> bool:
        """Log the notification using the standard logging system."""
        log_level = notification.level.name.lower()
        log_method = getattr(logger, log_level, logger.info)

        # Format a detailed log message
        message = (
            f"{notification.notification_type.value.upper()}: {notification.message}"
        )
        if notification.source:
            message = f"{message} (Source: {notification.source})"

        # Add details as structured logging
        log_method(message, extra=notification.details)
        return True


class DatabaseSubscriber(NotificationSubscriber):
    """Subscriber that stores notifications in a database."""

    def __init__(self, name: str, settings: dict[str, Any] | None = None) -> None:
        """Initialize the database subscriber."""
        super().__init__(name, settings)
        self.db_path = NOTIFICATION_DB_PATH
        self.max_age_days = self.settings.get("max_age_days", 30)
        self.max_per_type = NOTIFICATION_SETTINGS.get(
            "max_notifications_per_type", 1000
        )
        self.notifications = {}
        self.initialized = False

    async def initialize(self) -> None:
        """Load existing notifications from the database."""
        if self.initialized:
            return

        if self.db_path.exists():
            try:
                content = await AsyncFileIO.read_text(self.db_path)
                self.notifications = json.loads(content)
            except (OSError, json.JSONDecodeError) as e:
                logger.error(f"Error loading notification database: {e}")
                self.notifications = {}

        self.initialized = True

    async def _process_notification(self, notification: Notification) -> bool:
        """Store the notification in the database."""
        # Initialize if needed
        await self.initialize()

        # Get notifications of this type
        notification_type = notification.notification_type.value
        if notification_type not in self.notifications:
            self.notifications[notification_type] = []

        # Add the new notification
        self.notifications[notification_type].append(notification.to_dict())

        # Enforce maximum per type
        if len(self.notifications[notification_type]) > self.max_per_type:
            # Sort by timestamp (newest first) and trim
            self.notifications[notification_type].sort(
                key=lambda n: n["timestamp"], reverse=True
            )
            self.notifications[notification_type] = self.notifications[
                notification_type
            ][: self.max_per_type]

        # Save to disk
        await self._save_notifications()

        return True

    async def _save_notifications(self) -> bool:
        """Save notifications to the database file."""
        try:
            content = json.dumps(self.notifications, indent=2)
            return await AsyncFileIO.write(self.db_path, content)
        except Exception as e:
            logger.error(f"Error saving notifications: {e}")
            return False

    async def cleanup_old_notifications(self) -> int:
        """
        Remove notifications older than max_age_days.

        Returns:
            Number of notifications removed
        """
        await self.initialize()

        removed_count = 0
        cutoff_time = time.time() - (self.max_age_days * 86400)  # 86400 seconds per day

        for notification_type in self.notifications:
            original_count = len(self.notifications[notification_type])
            self.notifications[notification_type] = [
                n
                for n in self.notifications[notification_type]
                if n["timestamp"] >= cutoff_time
            ]
            removed_count += original_count - len(self.notifications[notification_type])

        if removed_count > 0:
            await self._save_notifications()
            logger.info(f"Removed {removed_count} old notifications")

        return removed_count


# Simple in-memory cache implementation for throttling
class SimpleCache(Generic[T]):
    """Simple in-memory cache with TTL."""

    def __init__(self, ttl: int = 60, max_size: int = 1000) -> None:
        """
        Initialize the cache.

        Args:
            ttl: Time-to-live in seconds
            max_size: Maximum number of items in cache
        """
        self.ttl = ttl
        self.max_size = max_size
        self.cache: dict[str, tuple[T, float]] = {}

    def get(self, key: str, default: T = None) -> T:  # type: ignore
        """Get value from cache, returning default if expired or not found."""
        if key not in self.cache:
            return default

        value, expiry = self.cache[key]
        if time.time() > expiry:
            # Expired
            del self.cache[key]
            return default

        return value

    def set(self, key: str, value: T) -> None:
        """Set value in cache with TTL."""
        # Clean up if we're at max size
        if len(self.cache) >= self.max_size and key not in self.cache:
            # Simple cleanup: remove expired items
            now = time.time()
            expired_keys = [k for k, (_, exp) in self.cache.items() if now > exp]
            for k in expired_keys:
                del self.cache[k]

            # If still at max size, remove random item
            if len(self.cache) >= self.max_size:
                if self.cache:
                    del self.cache[next(iter(self.cache))]

        self.cache[key] = (value, time.time() + self.ttl)


class NotificationManager:
    """
    Manages creation, storage, and delivery of notifications.

    This class implements a publisher-subscriber pattern for notifications,
    allowing components to subscribe to notifications and receive updates
    when new notifications are created.

    Features:
    - Asynchronous notification delivery
    - Persistence to JSON storage
    - Configurable retention policies
    - Filtering by type and level
    - Read/unread status tracking

    Attributes:
        _instance: Singleton instance reference
        _subscribers: Set of callback functions subscribed to notifications
        _notifications: Dictionary of stored notifications by ID
        _lock: Asyncio lock for thread safety
        max_notifications: Maximum number of notifications to keep
    """

    _instance = None
    _initialized = False

    def __new__(cls, *args: object, **kwargs: object) -> "NotificationManager":
        """Ensure NotificationManager is a singleton."""
        if cls._instance is None:
            cls._instance = super().__new__(cls)
        return cls._instance

    def __init__(self) -> None:
        """Initialize the notification manager."""
        if self._initialized:
            return

        # Load settings
        self.settings = NOTIFICATION_SETTINGS
        self.enabled = self.settings.get("enabled", True)

        # Set up throttling
        self.throttling_enabled = self.settings.get("throttling", {}).get(
            "enabled", True
        )
        self.throttle_window = self.settings.get("throttling", {}).get(
            "window_seconds", 60
        )
        self.max_similar = self.settings.get("throttling", {}).get("max_similar", 5)

        # Create throttling cache
        self.throttle_cache = SimpleCache[int](ttl=self.throttle_window, max_size=1000)

        # Set up subscribers
        self.subscribers: dict[str, NotificationSubscriber] = {}
        self._initialized = True

        # Initialize built-in subscribers
        self._setup_default_subscribers()

        # Initialize rule engine (imported here to avoid circular imports)
        try:
            from the_aichemist_codex.backend.notification.rule_engine import rule_engine

            self.rule_engine = rule_engine
            logger.debug("Rule engine initialized")
        except ImportError:
            logger.warning("Rule engine module not available")
            self.rule_engine = None

        logger.info("NotificationManager initialized")

    def _setup_default_subscribers(self) -> None:
        """Set up the default notification subscribers."""
        # Add logging subscriber
        log_settings = self.settings.get("channels", {}).get("log", {"enabled": True})
        if log_settings.get("enabled", True):
            self.add_subscriber("log", LogSubscriber("log", log_settings))

        # Add database subscriber
        db_settings = self.settings.get("channels", {}).get(
            "database", {"enabled": True}
        )
        if db_settings.get("enabled", True):
            self.add_subscriber("database", DatabaseSubscriber("database", db_settings))

        # Add email subscriber if enabled
        email_settings = self.settings.get("channels", {}).get(
            "email", {"enabled": False}
        )
        if email_settings.get("enabled", False):
            try:
                # Try to import the EmailSubscriber class
                # Using a more defensive approach to handle potential missing module
                email_module_name = (
                    "the_aichemist_codex.backend.notification.email_subscriber"
                )
                email_class_name = "EmailSubscriber"

                # First check if the module exists
                import importlib.util

                spec = importlib.util.find_spec(email_module_name)
                if spec is not None:
                    email_module = importlib.import_module(email_module_name)
                    if hasattr(email_module, email_class_name):
                        email_subscriber_class = getattr(email_module, email_class_name)
                        self.add_subscriber(
                            "email", email_subscriber_class("email", email_settings)
                        )
                        logger.info("Email notification subscriber registered")
                    else:
                        logger.warning(
                            f"EmailSubscriber class not found in {email_module_name}"
                        )
                else:
                    logger.warning(
                        f"Email subscriber module not found: {email_module_name}"
                    )
            except Exception as e:
                logger.warning(f"Failed to load email subscriber: {e}")

        # Add webhook subscriber if enabled
        webhook_settings = self.settings.get("channels", {}).get(
            "webhook", {"enabled": False}
        )
        if webhook_settings.get("enabled", False):
            try:
                # Try to import the WebhookSubscriber class
                # Using a more defensive approach to handle potential missing module
                webhook_module_name = (
                    "the_aichemist_codex.backend.notification.webhook_subscriber"
                )
                webhook_class_name = "WebhookSubscriber"

                # First check if the module exists
                import importlib.util

                spec = importlib.util.find_spec(webhook_module_name)
                if spec is not None:
                    webhook_module = importlib.import_module(webhook_module_name)
                    if hasattr(webhook_module, webhook_class_name):
                        webhook_subscriber_class = getattr(
                            webhook_module, webhook_class_name
                        )
                        self.add_subscriber(
                            "webhook",
                            webhook_subscriber_class("webhook", webhook_settings),
                        )
                        logger.info("Webhook notification subscriber registered")
                    else:
                        logger.warning(
                            f"WebhookSubscriber class not found "
                            f"in {webhook_module_name}"
                        )
                else:
                    logger.warning(
                        f"Webhook subscriber module not found: {webhook_module_name}"
                    )
            except Exception as e:
                logger.warning(f"Failed to load webhook subscriber: {e}")

    def add_subscriber(self, name: str, subscriber: NotificationSubscriber) -> None:
        """
        Register a new notification subscriber.

        Args:
            name: Unique name for the subscriber
            subscriber: The subscriber instance
        """
        self.subscribers[name] = subscriber
        logger.debug(f"Added notification subscriber: {name}")

    def remove_subscriber(self, name: str) -> bool:
        """
        Remove a notification subscriber.

        Args:
            name: Name of the subscriber to remove

        Returns:
            True if the subscriber was removed
        """
        if name in self.subscribers:
            del self.subscribers[name]
            logger.debug(f"Removed notification subscriber: {name}")
            return True
        return False

    async def notify(
        self,
        message: str,
        level: str | NotificationLevel = NotificationLevel.INFO,
        notification_type: str | NotificationType = NotificationType.SYSTEM,
        source: str = "",
        details: dict[str, Any] | None = None,
    ) -> str | None:
        """
        Create and publish a notification to all subscribers.

        Args:
            message: The notification message
            level: Severity level
            notification_type: Category of notification
            source: Source of the notification
            details: Additional structured data

        Returns:
            Notification ID if published, None if throttled or disabled
        """
        if not self.enabled:
            return None

        # Create the notification
        notification = Notification(
            message=message,
            level=level,
            notification_type=notification_type,
            source=source,
            details=details or {},
        )

        # Process through rule engine if available
        subscribers_to_notify = None
        if hasattr(self, "rule_engine") and self.rule_engine is not None:
            try:
                # Create context for rule evaluation
                context = {
                    "manager": self,
                    "timestamp": time.time(),
                }

                # Process notification through rule engine
                result = await self.rule_engine.process_notification(
                    notification, context
                )

                # Check if notification was blocked by rules
                if result["blocked"]:
                    logger.debug(f"Notification blocked by rules: {notification}")
                    return None

                # Use potentially modified notification
                if result["modified"]:
                    notification = result["notification"]

                # Apply custom throttling if specified
                if result["throttle_params"]:
                    # Custom throttling logic could be implemented here
                    pass

                # Check if specific subscribers are targeted
                if result["subscribers"] is not None:
                    subscribers_to_notify = result["subscribers"]

                if result["matched_rules"]:
                    logger.debug(
                        f"Notification matched rules: "
                        f"{', '.join(result['matched_rules'])}"
                    )
            except Exception as e:
                logger.error(f"Error processing notification through rule engine: {e}")

        # Check throttling
        if self.throttling_enabled and await self._should_throttle(notification):
            logger.debug(f"Throttled notification: {notification}")
            return None

        # Publish to all or selected subscribers
        tasks = []
        for name, subscriber in self.subscribers.items():
            # Skip subscribers not in the target list if specified
            if subscribers_to_notify is not None and name not in subscribers_to_notify:
                continue

            tasks.append(subscriber.notify(notification))

        # Wait for all subscribers to process
        if tasks:
            await asyncio.gather(*tasks)

        return notification.id

    async def _should_throttle(self, notification: Notification) -> bool:
        """
        Check if a notification should be throttled based on similarity.

        Args:
            notification: The notification to check

        Returns:
            True if notification should be throttled
        """
        # Create a throttling key based on type, level, and message
        throttle_key = (
            f"{notification.notification_type.value}:"
            f"{notification.level.name}:{notification.message}"
        )

        # Get current count for this key
        current_count = self.throttle_cache.get(throttle_key, 0)

        # Increment count
        self.throttle_cache.set(throttle_key, current_count + 1)

        # Throttle if over the limit
        return current_count >= self.max_similar

    async def get_notifications(
        self,
        notification_type: str | NotificationType | None = None,
        level: str | NotificationLevel | None = None,
        start_time: float | None = None,
        end_time: float | None = None,
        limit: int = 100,
        offset: int = 0,
    ) -> list[dict[str, Any]]:
        """
        Get notifications from the database.

        Args:
            notification_type: Filter by notification type
            level: Filter by minimum notification level
            start_time: Filter by start time (timestamp)
            end_time: Filter by end time (timestamp)
            limit: Maximum number of notifications to return
            offset: Number of notifications to skip

        Returns:
            List of notification dictionaries
        """
        # Get the database subscriber
        db_subscriber = self.subscribers.get("database")
        if not db_subscriber or not isinstance(db_subscriber, DatabaseSubscriber):
            logger.warning("Database subscriber not available")
            return []

        # Initialize the database
        await db_subscriber.initialize()

        # Convert type and level to correct format
        if isinstance(notification_type, NotificationType):
            notification_type = notification_type.value

        min_level = None
        if level is not None:
            if isinstance(level, str):
                min_level = NotificationLevel.from_string(level)
            else:
                min_level = level

        # Collect matching notifications
        result = []

        # Determine which notification types to include
        types_to_include = (
            [notification_type]
            if notification_type
            else list(db_subscriber.notifications.keys())
        )

        # Process each type
        for ntype in types_to_include:
            if ntype not in db_subscriber.notifications:
                continue

            for notification_dict in db_subscriber.notifications[ntype]:
                # Apply filters
                if (
                    start_time is not None
                    and notification_dict["timestamp"] < start_time
                ):
                    continue
                if end_time is not None and notification_dict["timestamp"] > end_time:
                    continue
                if (
                    min_level is not None
                    and NotificationLevel.from_string(notification_dict["level"])
                    < min_level
                ):
                    continue

                result.append(notification_dict)

        # Sort by timestamp (newest first)
        result.sort(key=lambda n: n["timestamp"], reverse=True)

        # Apply pagination
        return result[offset : offset + limit]

    async def get_notification_by_id(
        self, notification_id: str
    ) -> dict[str, Any] | None:
        """
        Get a specific notification by ID.

        Args:
            notification_id: The ID of the notification to find

        Returns:
            Notification dictionary if found, None otherwise
        """
        # Get the database subscriber
        db_subscriber = self.subscribers.get("database")
        if not db_subscriber or not isinstance(db_subscriber, DatabaseSubscriber):
            logger.warning("Database subscriber not available")
            return None

        # Initialize the database
        await db_subscriber.initialize()

        # Search for the notification
        for notifications in db_subscriber.notifications.values():
            for notification_dict in notifications:
                if notification_dict["id"] == notification_id:
                    return notification_dict

        return None

    async def cleanup(self) -> int:
        """
        Clean up old notifications.

        Returns:
            Number of notifications removed
        """
        db_subscriber = self.subscribers.get("database")
        if not db_subscriber or not isinstance(db_subscriber, DatabaseSubscriber):
            logger.warning("Database subscriber not available for cleanup")
            return 0

        return await db_subscriber.cleanup_old_notifications()


# Create a singleton instance
notification_manager = NotificationManager()



================================================
File: src/the_aichemist_codex/backend/notification/rule_engine.py
================================================
"""
Notification Rules Engine for The Aichemist Codex.

This module provides a flexible rules system for filtering and routing notifications
based on customizable conditions and actions.
"""

import datetime
import logging
import re
from enum import Enum
from re import Pattern
from typing import Any, TypeVar

from the_aichemist_codex.backend.config.settings import DATA_DIR
from the_aichemist_codex.backend.notification.notification_manager import (
    Notification,
    NotificationLevel,
    NotificationType,
)
from the_aichemist_codex.backend.utils.async_io import AsyncFileIO

logger = logging.getLogger(__name__)

# Define rules database path
RULES_DB_PATH = DATA_DIR / "notification_rules.json"

# Define a type variable for rule condition values
RuleValueType = TypeVar("RuleValueType")


class ConditionOperator(Enum):
    """Operators for rule conditions."""

    EQUALS = "equals"
    NOT_EQUALS = "not_equals"
    CONTAINS = "contains"
    NOT_CONTAINS = "not_contains"
    STARTS_WITH = "starts_with"
    ENDS_WITH = "ends_with"
    MATCHES_REGEX = "matches_regex"
    GREATER_THAN = "greater_than"
    LESS_THAN = "less_than"
    IN_LIST = "in_list"
    NOT_IN_LIST = "not_in_list"
    IS_TRUE = "is_true"
    IS_FALSE = "is_false"
    IS_NONE = "is_none"
    IS_NOT_NONE = "is_not_none"


class TimeConditionType(Enum):
    """Types of time-based conditions."""

    TIME_OF_DAY = "time_of_day"
    DAY_OF_WEEK = "day_of_week"
    DATE_RANGE = "date_range"
    FREQUENCY = "frequency"  # e.g., "no more than X in Y minutes"


class ActionType(Enum):
    """Types of actions that can be taken when a rule matches."""

    ROUTE = "route"  # Route to specific subscribers
    TRANSFORM = "transform"  # Transform the notification
    THROTTLE = "throttle"  # Apply custom throttling
    ENRICH = "enrich"  # Add additional data
    BLOCK = "block"  # Block the notification


class RuleCondition:
    """Represents a single condition in a notification rule."""

    def __init__(
        self,
        field: str,
        operator: str | ConditionOperator,
        value: Any,  # noqa: ANN401
        negate: bool = False,
    ) -> None:
        """
        Initialize a rule condition.

        Args:
            field: The notification field to check (e.g., "level", "message")
            operator: The comparison operator
            value: The value to compare against
            negate: Whether to negate the result
        """
        self.field = field
        self.operator = (
            operator
            if isinstance(operator, ConditionOperator)
            else ConditionOperator(operator)
        )
        self.value = value
        self.negate = negate
        self._regex_cache: Pattern | None = None

    async def evaluate(self, notification: Notification) -> bool:
        """
        Evaluate the condition against a notification.

        Args:
            notification: The notification to check

        Returns:
            True if the condition matches, False otherwise
        """
        # Get the field value from the notification
        field_value = self._get_field_value(notification)

        # Evaluate based on operator
        result = await self._evaluate_operator(field_value)

        # Apply negation if needed
        return not result if self.negate else result

    def _get_field_value(self, notification: Notification) -> Any:  # noqa: ANN401
        """Get a field value from the notification."""
        if self.field == "level":
            return notification.level
        elif self.field == "type":
            return notification.notification_type
        elif self.field == "message":
            return notification.message
        elif self.field == "source":
            return notification.source
        elif self.field == "timestamp":
            return notification.timestamp
        elif self.field.startswith("details."):
            # Get nested field from details
            detail_field = self.field[8:]  # Remove "details." prefix
            return notification.details.get(detail_field)
        return None

    async def _evaluate_operator(
        self,
        field_value: Any,  # noqa: ANN401
    ) -> bool:
        """Evaluate the operator against the field value."""
        if self.operator == ConditionOperator.EQUALS:
            if isinstance(field_value, Enum):
                if isinstance(self.value, str):
                    # Handle string comparison with enum
                    return (
                        field_value.name == self.value.upper()
                        or field_value.value == self.value.lower()
                    )
                return field_value == self.value
            return field_value == self.value

        elif self.operator == ConditionOperator.NOT_EQUALS:
            if isinstance(field_value, Enum):
                if isinstance(self.value, str):
                    return not (
                        field_value.name == self.value.upper()
                        or field_value.value == self.value.lower()
                    )
                return field_value != self.value
            return field_value != self.value

        elif self.operator == ConditionOperator.CONTAINS:
            if field_value is None:
                return False
            return self.value in str(field_value)

        elif self.operator == ConditionOperator.NOT_CONTAINS:
            if field_value is None:
                return True
            return self.value not in str(field_value)

        elif self.operator == ConditionOperator.STARTS_WITH:
            if field_value is None:
                return False
            return str(field_value).startswith(self.value)

        elif self.operator == ConditionOperator.ENDS_WITH:
            if field_value is None:
                return False
            return str(field_value).endswith(self.value)

        elif self.operator == ConditionOperator.MATCHES_REGEX:
            if field_value is None:
                return False
            if self._regex_cache is None:
                self._regex_cache = re.compile(self.value)
            return bool(self._regex_cache.search(str(field_value)))

        elif self.operator == ConditionOperator.GREATER_THAN:
            if field_value is None:
                return False
            return field_value > self.value

        elif self.operator == ConditionOperator.LESS_THAN:
            if field_value is None:
                return False
            return field_value < self.value

        elif self.operator == ConditionOperator.IN_LIST:
            if field_value is None:
                return False
            if isinstance(field_value, Enum):
                # Check if enum name or value is in list
                return field_value.name in self.value or field_value.value in self.value
            return field_value in self.value

        elif self.operator == ConditionOperator.NOT_IN_LIST:
            if field_value is None:
                return True
            if isinstance(field_value, Enum):
                return (
                    field_value.name not in self.value
                    and field_value.value not in self.value
                )
            return field_value not in self.value

        elif self.operator == ConditionOperator.IS_TRUE:
            return bool(field_value) is True

        elif self.operator == ConditionOperator.IS_FALSE:
            return bool(field_value) is False

        elif self.operator == ConditionOperator.IS_NONE:
            return field_value is None

        elif self.operator == ConditionOperator.IS_NOT_NONE:
            return field_value is not None

        # Default case
        return False

    def to_dict(self) -> dict[str, Any]:
        """Convert to dictionary for serialization."""
        return {
            "field": self.field,
            "operator": self.operator.value,
            "value": self.value,
            "negate": self.negate,
        }

    @classmethod
    def from_dict(cls, data: dict[str, Any]) -> "RuleCondition":
        """Create from dictionary (for deserialization)."""
        return cls(
            field=data["field"],
            operator=data["operator"],
            value=data["value"],
            negate=data.get("negate", False),
        )


class TimeCondition:
    """Represents a time-based condition for a notification rule."""

    def __init__(
        self,
        condition_type: str | TimeConditionType,
        value: Any,  # noqa: ANN401 - Value depends on condition type
    ) -> None:
        """
        Initialize a time condition.

        Args:
            condition_type: The type of time condition
            value: The value for the condition (format depends on type)
        """
        self.condition_type = (
            condition_type
            if isinstance(condition_type, TimeConditionType)
            else TimeConditionType(condition_type)
        )
        self.value = value

    async def evaluate(self) -> bool:
        """
        Evaluate the time condition.

        Returns:
            True if the condition matches the current time, False otherwise
        """
        now = datetime.datetime.now()

        if self.condition_type == TimeConditionType.TIME_OF_DAY:
            # Format: {"start": "HH:MM", "end": "HH:MM"}
            start_time = datetime.datetime.strptime(self.value["start"], "%H:%M").time()
            end_time = datetime.datetime.strptime(self.value["end"], "%H:%M").time()
            current_time = now.time()
            return start_time <= current_time <= end_time

        elif self.condition_type == TimeConditionType.DAY_OF_WEEK:
            # Format: [0, 1, 2, 3, 4, 5, 6] where 0 is Monday
            return now.weekday() in self.value

        elif self.condition_type == TimeConditionType.DATE_RANGE:
            # Format: {"start": "YYYY-MM-DD", "end": "YYYY-MM-DD"}
            start_date = datetime.datetime.strptime(
                self.value["start"], "%Y-%m-%d"
            ).date()
            end_date = datetime.datetime.strptime(self.value["end"], "%Y-%m-%d").date()
            current_date = now.date()
            return start_date <= current_date <= end_date

        elif self.condition_type == TimeConditionType.FREQUENCY:
            # Handled by RuleEngine directly
            return True

        return False

    def to_dict(self) -> dict[str, Any]:
        """Convert to dictionary for serialization."""
        return {
            "condition_type": self.condition_type.value,
            "value": self.value,
        }

    @classmethod
    def from_dict(cls, data: dict[str, Any]) -> "TimeCondition":
        """Create from dictionary (for deserialization)."""
        return cls(
            condition_type=data["condition_type"],
            value=data["value"],
        )


class RuleAction:
    """Represents an action to take when a rule is matched."""

    def __init__(
        self,
        action_type: str | ActionType,
        parameters: dict[str, Any],
    ) -> None:
        """
        Initialize a rule action.

        Args:
            action_type: The type of action
            parameters: Parameters for the action
        """
        self.action_type = (
            action_type
            if isinstance(action_type, ActionType)
            else ActionType(action_type)
        )
        self.parameters = parameters

    async def apply(
        self, notification: Notification, context: dict[str, Any]
    ) -> Notification:
        """
        Apply the action to a notification.

        Args:
            notification: The notification to modify
            context: Additional context for the action

        Returns:
            The modified notification
        """
        if self.action_type == ActionType.ROUTE:
            # Routing is handled by the rule engine
            return notification

        elif self.action_type == ActionType.TRANSFORM:
            # Apply transformations to the notification
            if "level" in self.parameters:
                notification.level = NotificationLevel.from_string(
                    self.parameters["level"]
                )

            if "type" in self.parameters:
                try:
                    notification.notification_type = NotificationType(
                        self.parameters["type"]
                    )
                except ValueError:
                    pass

            if "message" in self.parameters:
                message_template = self.parameters["message"]
                try:
                    # Replace placeholders with values from the notification
                    notification.message = message_template.format(
                        level=notification.level.name,
                        type=notification.notification_type.value,
                        source=notification.source,
                        message=notification.message,
                        **notification.details,
                    )
                except (KeyError, ValueError):
                    # If formatting fails, keep the original message
                    pass

            if "source" in self.parameters:
                notification.source = self.parameters["source"]

            return notification

        elif self.action_type == ActionType.ENRICH:
            # Add additional data to the notification
            if "add_fields" in self.parameters:
                for key, value in self.parameters["add_fields"].items():
                    if key not in notification.details:
                        notification.details[key] = value

            if "add_context" in self.parameters and context:
                for key in self.parameters["add_context"]:
                    if key in context and key not in notification.details:
                        notification.details[key] = context[key]

            return notification

        elif self.action_type == ActionType.BLOCK:
            # Blocking is handled by the rule engine
            return notification

        elif self.action_type == ActionType.THROTTLE:
            # Throttling is handled by the rule engine
            return notification

        return notification

    def to_dict(self) -> dict[str, Any]:
        """Convert to dictionary for serialization."""
        return {
            "action_type": self.action_type.value,
            "parameters": self.parameters,
        }

    @classmethod
    def from_dict(cls, data: dict[str, Any]) -> "RuleAction":
        """Create from dictionary (for deserialization)."""
        return cls(
            action_type=data["action_type"],
            parameters=data["parameters"],
        )


class NotificationRule:
    """Represents a rule for processing notifications."""

    def __init__(
        self,
        name: str,
        description: str,
        conditions: list[RuleCondition],
        time_conditions: list[TimeCondition] | None = None,
        actions: list[RuleAction] | None = None,
        enabled: bool = True,
        priority: int = 100,
        subscribers: list[str] | None = None,
        rule_id: str | None = None,
    ) -> None:
        """
        Initialize a notification rule.

        Args:
            name: Name of the rule
            description: Description of what the rule does
            conditions: List of conditions that must be met
            time_conditions: Optional time-based conditions
            actions: Actions to take when the rule matches
            enabled: Whether the rule is active
            priority: Rule priority (lower numbers = higher priority)
            subscribers: List of subscribers to route to (None = all)
            rule_id: Unique identifier for the rule
        """
        self.name = name
        self.description = description
        self.conditions = conditions or []
        self.time_conditions = time_conditions or []
        self.actions = actions or []
        self.enabled = enabled
        self.priority = priority
        self.subscribers = subscribers  # None means all subscribers
        self.rule_id = rule_id or f"rule_{int(datetime.datetime.now().timestamp())}"
        self.match_count = 0
        self.last_match_time: float | None = None

    async def matches(
        self, notification: Notification, context: dict[str, Any] | None = None
    ) -> bool:
        """
        Check if a notification matches this rule.

        Args:
            notification: The notification to check
            context: Additional context for evaluation

        Returns:
            True if the rule matches, False otherwise
        """
        if not self.enabled:
            return False

        # Check all conditions
        for condition in self.conditions:
            if not await condition.evaluate(notification):
                return False

        # Check time conditions
        for time_condition in self.time_conditions:
            if not await time_condition.evaluate():
                return False

        # If we got here, all conditions matched
        self.match_count += 1
        self.last_match_time = datetime.datetime.now().timestamp()
        return True

    async def apply_actions(
        self, notification: Notification, context: dict[str, Any] | None = None
    ) -> Notification:
        """
        Apply all actions to a notification.

        Args:
            notification: The notification to modify
            context: Additional context for actions

        Returns:
            The modified notification
        """
        context = context or {}
        modified_notification = notification

        for action in self.actions:
            modified_notification = await action.apply(modified_notification, context)

        return modified_notification

    def should_block(self) -> bool:
        """Check if this rule blocks the notification."""
        return any(action.action_type == ActionType.BLOCK for action in self.actions)

    def should_throttle(self) -> dict[str, Any] | None:
        """
        Check if this rule applies custom throttling.

        Returns:
            Throttling parameters or None
        """
        for action in self.actions:
            if action.action_type == ActionType.THROTTLE:
                return action.parameters
        return None

    def get_route_subscribers(self) -> list[str] | None:
        """
        Get the subscribers this rule routes to.

        Returns:
            List of subscriber names or None (all subscribers)
        """
        for action in self.actions:
            if action.action_type == ActionType.ROUTE:
                return action.parameters.get("subscribers")
        return self.subscribers

    def to_dict(self) -> dict[str, Any]:
        """Convert to dictionary for serialization."""
        return {
            "rule_id": self.rule_id,
            "name": self.name,
            "description": self.description,
            "conditions": [c.to_dict() for c in self.conditions],
            "time_conditions": [tc.to_dict() for tc in self.time_conditions],
            "actions": [a.to_dict() for a in self.actions],
            "enabled": self.enabled,
            "priority": self.priority,
            "subscribers": self.subscribers,
            "stats": {
                "match_count": self.match_count,
                "last_match_time": self.last_match_time,
            },
        }

    @classmethod
    def from_dict(cls, data: dict[str, Any]) -> "NotificationRule":
        """Create from dictionary (for deserialization)."""
        rule = cls(
            name=data["name"],
            description=data["description"],
            conditions=[RuleCondition.from_dict(c) for c in data["conditions"]],
            time_conditions=[
                TimeCondition.from_dict(tc) for tc in data.get("time_conditions", [])
            ],
            actions=[RuleAction.from_dict(a) for a in data.get("actions", [])],
            enabled=data.get("enabled", True),
            priority=data.get("priority", 100),
            subscribers=data.get("subscribers"),
            rule_id=data["rule_id"],
        )

        # Restore statistics if available
        if "stats" in data:
            rule.match_count = data["stats"].get("match_count", 0)
            rule.last_match_time = data["stats"].get("last_match_time")

        return rule


class RuleEngine:
    """
    Engine for evaluating notification rules.

    The rule engine provides:
    - Rule storage and retrieval
    - Rule evaluation against notifications
    - Custom notification routing based on rules
    - Statistics about rule matches
    """

    def __init__(self) -> None:
        """Initialize the rule engine."""
        self.rules: list[NotificationRule] = []
        self.initialized = False
        self.frequency_cache: dict[str, list[float]] = {}

    async def initialize(self) -> None:
        """Load rules from storage."""
        if self.initialized:
            return

        # Create rule storage if it doesn't exist
        if not RULES_DB_PATH.exists():
            await AsyncFileIO.write_json(RULES_DB_PATH, {"rules": []})

        # Load rules
        try:
            data = await AsyncFileIO.read_json(RULES_DB_PATH)
            self.rules = [
                NotificationRule.from_dict(rule_data)
                for rule_data in data.get("rules", [])
            ]
            self.rules.sort(key=lambda r: r.priority)
        except Exception as e:
            logger.error(f"Error loading notification rules: {e}")
            self.rules = []

        self.initialized = True
        logger.info(f"Loaded {len(self.rules)} notification rules")

    async def save_rules(self) -> None:
        """Save rules to storage."""
        try:
            data = {"rules": [rule.to_dict() for rule in self.rules]}
            await AsyncFileIO.write_json(RULES_DB_PATH, data)
        except Exception as e:
            logger.error(f"Error saving notification rules: {e}")

    async def add_rule(self, rule: NotificationRule) -> str:
        """
        Add a new rule to the engine.

        Args:
            rule: The rule to add

        Returns:
            The rule ID
        """
        await self.initialize()
        self.rules.append(rule)
        self.rules.sort(key=lambda r: r.priority)
        await self.save_rules()
        return rule.rule_id

    async def update_rule(self, rule: NotificationRule) -> bool:
        """
        Update an existing rule.

        Args:
            rule: The updated rule

        Returns:
            True if the rule was updated, False if not found
        """
        await self.initialize()
        for i, existing_rule in enumerate(self.rules):
            if existing_rule.rule_id == rule.rule_id:
                self.rules[i] = rule
                self.rules.sort(key=lambda r: r.priority)
                await self.save_rules()
                return True
        return False

    async def delete_rule(self, rule_id: str) -> bool:
        """
        Delete a rule.

        Args:
            rule_id: The ID of the rule to delete

        Returns:
            True if the rule was deleted, False if not found
        """
        await self.initialize()
        initial_count = len(self.rules)
        self.rules = [r for r in self.rules if r.rule_id != rule_id]
        if len(self.rules) < initial_count:
            await self.save_rules()
            return True
        return False

    async def get_rule(self, rule_id: str) -> NotificationRule | None:
        """
        Get a rule by ID.

        Args:
            rule_id: The rule ID

        Returns:
            The rule or None if not found
        """
        await self.initialize()
        for rule in self.rules:
            if rule.rule_id == rule_id:
                return rule
        return None

    async def get_all_rules(self) -> list[dict[str, Any]]:
        """
        Get all rules.

        Returns:
            List of rule dictionaries
        """
        await self.initialize()
        return [rule.to_dict() for rule in self.rules]

    async def process_notification(
        self, notification: Notification, context: dict[str, Any] | None = None
    ) -> dict[str, Any]:
        """
        Process a notification through the rule engine.

        Args:
            notification: The notification to process
            context: Additional context for rule evaluation

        Returns:
            Dictionary with processing results:
            {
                "blocked": bool,  # Whether the notification was blocked
                "modified": bool,  # Whether the notification was modified
                "notification": Notification,  # The (possibly) modified notification
                "subscribers": list[str] | None,  # Subscribers to route to (None = all)
                "throttle_params": dict | None,  # Custom throttling parameters
                "matched_rules": list[str]  # IDs of rules that matched
            }
        """
        await self.initialize()
        context = context or {}
        modified_notification = notification
        result = {
            "blocked": False,
            "modified": False,
            "notification": notification,
            "subscribers": None,  # None means all subscribers
            "throttle_params": None,
            "matched_rules": [],
        }

        # Check frequency-based time conditions
        await self._update_frequency_cache(notification)

        # Process rules in priority order
        for rule in self.rules:
            # Add frequency cache to context
            context["frequency_cache"] = self.frequency_cache

            # Check if rule matches
            if await rule.matches(modified_notification, context):
                result["matched_rules"].append(rule.rule_id)

                # Check if rule blocks the notification
                if rule.should_block():
                    result["blocked"] = True
                    break

                # Apply rule actions
                new_notification = await rule.apply_actions(
                    modified_notification, context
                )
                if new_notification is not modified_notification:
                    modified_notification = new_notification
                    result["modified"] = True

                # Check for throttling
                throttle_params = rule.should_throttle()
                if throttle_params:
                    result["throttle_params"] = throttle_params

                # Check for routing
                subscribers = rule.get_route_subscribers()
                if subscribers is not None:
                    result["subscribers"] = subscribers

        result["notification"] = modified_notification
        return result

    async def _update_frequency_cache(self, notification: Notification) -> None:
        """
        Update the frequency cache for a notification.

        This is used for frequency-based time conditions.

        Args:
            notification: The notification to add to the cache
        """
        # Create cache keys based on notification properties
        cache_keys = [
            f"level:{notification.level.name}",
            f"type:{notification.notification_type.value}",
            f"source:{notification.source}"
            if notification.source
            else "source:unknown",
        ]

        # Add keys for specific combinations
        cache_keys.append(
            f"level:{notification.level.name}:type:{notification.notification_type.value}"
        )

        # Add the current timestamp to each relevant cache entry
        now = datetime.datetime.now().timestamp()
        for key in cache_keys:
            if key not in self.frequency_cache:
                self.frequency_cache[key] = []
            self.frequency_cache[key].append(now)

            # Clean up old entries (older than 1 hour)
            one_hour_ago = now - 3600
            self.frequency_cache[key] = [
                ts for ts in self.frequency_cache[key] if ts > one_hour_ago
            ]

    async def simulate_rule(
        self, rule: NotificationRule, notification: Notification
    ) -> dict[str, Any]:
        """
        Simulate a rule against a notification without side effects.

        Args:
            rule: The rule to simulate
            notification: The notification to test

        Returns:
            Simulation results
        """
        matches = await rule.matches(notification)
        modified_notification = None
        if matches:
            modified_notification = await rule.apply_actions(notification, {})

        return {
            "rule": rule.to_dict(),
            "matches": matches,
            "notification_before": notification.to_dict(),
            "notification_after": (
                modified_notification.to_dict() if modified_notification else None
            ),
            "would_block": rule.should_block() if matches else False,
            "would_route_to": rule.get_route_subscribers() if matches else None,
            "would_throttle": rule.should_throttle() if matches else None,
        }


# Create a singleton instance
rule_engine = RuleEngine()



================================================
File: src/the_aichemist_codex/backend/notification/webhook_subscriber.py
================================================
"""Webhook subscriber for the notification system."""

import asyncio
import json
import logging
from typing import Any

# Try to import aiohttp, but handle case when it's not installed
try:
    import aiohttp

    AIOHTTP_AVAILABLE = True
except ImportError:
    AIOHTTP_AVAILABLE = False

from the_aichemist_codex.backend.notification.notification_manager import (
    Notification,
    NotificationSubscriber,
)

logger = logging.getLogger(__name__)


class WebhookSubscriber(NotificationSubscriber):
    """Subscriber that sends notifications to external webhooks."""

    def __init__(self, name: str, settings: dict[str, Any] | None = None):
        """
        Initialize the webhook subscriber.

        Args:
            name: Name of the subscriber
            settings: Subscriber-specific settings including:
                - urls: List of webhook URLs
                - headers: Optional HTTP headers to include
                - timeout: Request timeout in seconds
                - retry_count: Number of times to retry on failure
                - retry_delay: Seconds to wait between retries
        """
        super().__init__(name, settings)

        # Check if aiohttp is available
        if not AIOHTTP_AVAILABLE:
            logger.error(
                "aiohttp package is required for WebhookSubscriber but is not installed"
            )
            self.enabled = False
            return

        # Extract webhook-specific settings
        self.urls = self.settings.get("urls", [])
        self.headers = self.settings.get(
            "headers", {"Content-Type": "application/json"}
        )
        self.timeout = self.settings.get("timeout", 10)
        self.retry_count = self.settings.get("retry_count", 2)
        self.retry_delay = self.settings.get("retry_delay", 1)

        # Validate required settings
        if not self.urls:
            logger.warning("WebhookSubscriber initialized with no URLs")
            self.enabled = False

    async def _process_notification(self, notification: Notification) -> bool:
        """
        Send notification to all configured webhooks.

        Args:
            notification: The notification to send

        Returns:
            True if notification was sent to at least one webhook
        """
        if not AIOHTTP_AVAILABLE or not self.urls:
            return False

        # Prepare the payload
        payload = notification.to_dict()

        # Add additional metadata that might be useful for webhook receivers
        payload["webhook_source"] = f"aichemist_codex_{self.name}"

        # Serialize the payload
        try:
            json_payload = json.dumps(payload)
        except (TypeError, ValueError) as e:
            logger.error(f"Failed to serialize webhook payload: {e}")
            return False

        # Send to all webhooks
        results = await asyncio.gather(
            *[self._send_to_webhook(url, json_payload) for url in self.urls],
            return_exceptions=True,
        )

        # Check if at least one succeeded
        return any(result is True for result in results)

    async def _send_to_webhook(self, url: str, payload: str) -> bool:
        """
        Send notification to a single webhook with retries.

        Args:
            url: The webhook URL
            payload: JSON payload to send

        Returns:
            True if the notification was sent successfully
        """
        if not AIOHTTP_AVAILABLE:
            return False

        # Try multiple times if configured
        for attempt in range(self.retry_count + 1):
            try:
                # Use timeout to avoid hanging on unresponsive webhooks
                async with aiohttp.ClientSession() as session:
                    async with session.post(
                        url,
                        data=payload,
                        headers=self.headers,
                        timeout=aiohttp.ClientTimeout(total=self.timeout),
                    ) as response:
                        # Check if response was successful
                        if 200 <= response.status < 300:
                            logger.debug(f"Webhook notification sent to {url}")
                            return True
                        else:
                            error_text = await response.text()
                            logger.warning(
                                f"Webhook notification failed with status {response.status}: {error_text}"
                            )
            except TimeoutError:
                logger.warning(
                    f"Webhook request to {url} timed out after {self.timeout}s"
                )
            except aiohttp.ClientError as e:
                logger.warning(f"Webhook request to {url} failed: {e}")
            except Exception as e:
                logger.error(f"Unexpected error sending webhook to {url}: {e}")

            # If this wasn't the last attempt, wait before retrying
            if attempt < self.retry_count:
                await asyncio.sleep(self.retry_delay)

        return False

