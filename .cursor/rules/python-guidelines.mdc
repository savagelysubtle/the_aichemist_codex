---
description: Modern Python development best practices and guidelines
globs: **/*.py
alwaysApply: false
---
# Python Coding Guidelines

## 1. Project Structure
- Use the `src` layout for all packages:
  ```
  project_name/
  ├── src/
  │   └── project_name/
  │       ├── __init__.py
  │       ├── module1.py
  │       └── module2.py
  ├── tests/
  ├── docs/
  ├── pyproject.toml
  └── README.md
  ```
- Organize code using domain-driven architecture:
  - `domain/` → Core business entities and logic
  - `services/` → Application services implementing use cases
  - `infrastructure/` → External system interfaces (databases, APIs)
  - `interfaces/` → User-facing components (CLI, API, GUI)
  - `utils/` → Cross-cutting utilities

## 2. Modern Dependency Management
- Use `pyproject.toml` instead of `requirements.txt` or `setup.py`:
  ```toml
  [build-system]
  requires = ["setuptools>=61.0", "wheel"]
  build-backend = "setuptools.build_meta"

  [project]
  name = "project_name"
  version = "0.1.0"
  description = "Project description"
  requires-python = ">=3.10"
  dependencies = [
      "package1>=1.0.0",
      "package2>=2.3.4",
  ]

  [project.optional-dependencies]
  dev = [
      "pytest>=7.0.0",
      "mypy>=1.0.0",
      "ruff>=0.0.230",
  ]
  ```
- Consider using Poetry, PDM, or Hatch for more advanced dependency management

## 3. Coding Standards
- Target Python 3.10+ for all new code
- Follow **PEP 8** formatting (enforced with Ruff)
- Run code quality tools automatically with pre-commit

### Type Annotations
- Always use type annotations for all public interfaces
- Use modern type annotation syntax:
  ```python
  # Preferred (Python 3.10+)
  def process_data(items: list[str], options: dict[str, bool] | None = None) -> int: ...
  ```
- Use Protocols for structural typing instead of Abstract Base Classes when appropriate:
  ```python
  from typing import Protocol

  class Renderer(Protocol):
      def render(self, data: dict) -> str: ...
  ```
- Use TypeVar and Generic for creating properly typed generic classes:
  ```python
  from typing import Generic, TypeVar

  T = TypeVar('T')

  class Repository(Generic[T]):
      def get(self, id: str) -> T: ...
      def save(self, entity: T) -> None: ...
  ```

### Domain-Driven Design
- Use dataclasses or Pydantic models for domain entities:
  ```python
  from dataclasses import dataclass
  from datetime import datetime

  @dataclass(frozen=True)
  class User:
      id: str
      name: str
      email: str
      created_at: datetime
  ```
- Enforce invariants in domain models:
  ```python
  @dataclass
  class Order:
      items: list[OrderItem]

      def __post_init__(self):
          if not self.items:
              raise ValueError("Order must have at least one item")
  ```
- Use value objects for concepts with no identity:
  ```python
  @dataclass(frozen=True)
  class Money:
      amount: Decimal
      currency: str
  ```

### Error Handling
- Create a proper exception hierarchy:
  ```python
  class ApplicationError(Exception):
      """Base exception for all application errors."""

  class ValidationError(ApplicationError):
      """Raised when input validation fails."""

  class ResourceNotFoundError(ApplicationError):
      """Raised when a requested resource does not exist."""
  ```
- Use context managers for resource management:
  ```python
  with open("file.txt") as f:
      content = f.read()
  ```
- Handle exceptions at appropriate levels:
  ```python
  def data_access_function():
      try:
          # Database access
      except DatabaseError as e:
          # Log the error
          raise ResourceError("Could not retrieve resource") from e
  ```

## 4. Testing Best Practices
- Write tests first (TDD) when possible
- Use pytest for all testing:
  ```python
  def test_user_creation():
      user = User(name="Test", email="test@example.com")
      assert user.name == "Test"
      assert user.email == "test@example.com"
  ```
- Use fixtures for test setup:
  ```python
  @pytest.fixture
  def test_database():
      # Set up test database
      db = create_test_db()
      yield db
      # Teardown
      db.cleanup()
  ```
- Use parameterized tests for multiple scenarios:
  ```python
  @pytest.mark.parametrize("input,expected", [
      ("test", "TEST"),
      ("example", "EXAMPLE"),
  ])
  def test_uppercase(input, expected):
      assert input.upper() == expected
  ```
- Use property-based testing for complex behavior:
  ```python
  from hypothesis import given
  from hypothesis.strategies import text

  @given(text())
  def test_reversible_string_operation(s):
      assert reverse(reverse(s)) == s
  ```
- Organize tests to match production code structure:
  ```
  tests/
  ├── unit/             # Tests for individual components
  ├── integration/      # Tests for component interactions
  ├── e2e/              # End-to-end tests
  └── performance/      # Performance benchmarks
  ```

## 5. Configuration Management
- Use environment variables for deployment-specific settings
- Use Pydantic for configuration validation:
  ```python
  from pydantic import BaseSettings

  class Settings(BaseSettings):
      database_url: str
      api_key: str
      debug: bool = False

      class Config:
          env_file = ".env"
          env_file_encoding = "utf-8"
  ```
- Support multiple configuration sources (env vars, config files, etc.)
- Keep secrets out of code - use environment variables or secure vaults

## 6. Documentation
- Write docstrings for all public modules, classes and functions
- Use a consistent docstring style (Google or NumPy):
  ```python
  def calculate_total(items: list[Item], tax_rate: float = 0.0) -> float:
      """Calculate the total price of items with tax.

      Args:
          items: List of items to calculate total for
          tax_rate: Tax rate as a decimal (0.05 = 5%)

      Returns:
          Total price including tax

      Raises:
          ValueError: If tax_rate is negative
      """
  ```
- Generate API documentation with Sphinx
- Include usage examples in documentation

## 7. Performance Considerations
- Profile before optimizing
- Use appropriate data structures (collections, sortedcontainers)
- Consider asyncio for I/O-bound operations
- Use concurrent.futures for CPU-bound tasks
- Implement caching for expensive operations

## 8. Security Best Practices
- Validate all user inputs
- Use parameterized queries for database access
- Keep dependencies updated
- Follow the principle of least privilege
- Implement proper authentication and authorization
- Use secure defaults
