---
description: 
globs: 
alwaysApply: false
---
---
description: Details on using the Registry pattern to prevent circular imports
globs: **/*.py
alwaysApply: true
---
# Registry Pattern

## 1. What is the Registry Pattern?

The Registry pattern provides a central location to store and retrieve objects instead of importing them directly. In our architecture, it's the key mechanism for preventing circular imports:

```
┌─────────────┐      ┌─────────────┐
│ Module A    │      │ Module B    │
│             │      │             │
│ Uses B      │─────>│ Uses A      │
└─────────────┘      └─────────────┘
       │                    │
       │                    │
       ▼                    ▼
┌─────────────────────────────────┐
│          Registry               │
│                                 │
│ Holds instances of A and B      │
└─────────────────────────────────┘
```

## 2. Core Registry Implementation

Our Registry is a singleton that provides lazy initialization of services:

```python
class Registry:
    """Singleton registry for managing dependencies."""

    _instance = None

    @classmethod
    def get_instance(cls) -> "Registry":
        """Get the singleton instance."""
        if cls._instance is None:
            cls._instance = Registry()
        return cls._instance

    # Properties to access services
    @property
    def file_reader(self) -> FileReader:
        return self._lazy_load("file_reader", FileReader, self._create_file_reader)

    # Factory methods
    def _create_file_reader(self) -> FileReader:
        from .domain.file_reader.file_reader import FileReaderImpl
        return FileReaderImpl()
```

## 3. Using the Registry in Your Code

### Obtaining Services

Always obtain services through the Registry:

```python
from ...registry import Registry

# Get the registry instance
registry = Registry.get_instance()

# Access a service
file_reader = registry.file_reader
result = file_reader.read_text("path/to/file.txt")
```

### Implementing New Services

1. Define the interface in `core/interfaces.py`:
   ```python
   class MyService(ABC):
       @abstractmethod
       def do_something(self) -> str:
           pass
   ```

2. Add a property to the Registry:
   ```python
   @property
   def my_service(self) -> MyService:
       return self._lazy_load("my_service", MyService, self._create_my_service)

   def _create_my_service(self) -> MyService:
       from .domain.my_service.my_service import MyServiceImpl
       return MyServiceImpl()
   ```

3. Implement the service:
   ```python
   from ...core.interfaces import MyService as MyServiceInterface
   from ...registry import Registry

   class MyServiceImpl(MyServiceInterface):
       def __init__(self):
           self._registry = Registry.get_instance()
           # Access other services via registry
           self._another_service = self._registry.another_service

       def do_something(self) -> str:
           # Implementation here
           return "Result"
   ```

## 4. Bootstrapping the Application

The bootstrap process initializes the Registry with all the services in the correct order:

```python
def bootstrap():
    """Initialize the application."""
    # Get registry
    registry = Registry.get_instance()

    # Register services (this triggers lazy loading)
    paths = registry.project_paths
    config = registry.config_provider
    # etc.

    return registry
```

Always call bootstrap at the start of your application:

```python
from .bootstrap import bootstrap

# Initialize application
bootstrap()

# Now the registry is ready to use
registry = Registry.get_instance()
```

## 5. Benefits of the Registry Pattern

1. **Breaks Circular Dependencies**: Services don't directly import each other
2. **Lazy Initialization**: Services are only created when needed
3. **Centralized Configuration**: All services can be configured in one place
4. **Testability**: Services can be easily mocked or replaced for testing
5. **Flexibility**: Implementations can be changed without modifying client code

## 6. Potential Pitfalls

1. **Service Locator Anti-Pattern**: Avoid using the Registry directly in business logic
2. **Hidden Dependencies**: Dependencies aren't explicit in function signatures
3. **Singleton State**: Be careful with mutable state in the Registry

## 7. Best Practices

1. **Interface-Based Design**: Always define interfaces in the core layer
2. **Explicit Initialization**: Call bootstrap explicitly at application startup
3. **Factory Methods**: Use factory methods in the Registry to create services
4. **Dependency Injection**: Consider injecting the Registry into service constructors
5. **Testing**: Create a test Registry with mock implementations for testing

## 8. Architecture Validation

1. **Registry Usage Checks**: Add tests that verify all service implementations use the Registry for dependencies:
   ```python
   def test_implementation_uses_registry():
       """Verify that the implementation correctly uses the Registry."""
       with mock.patch('src.the_aichemist_codex.registry.Registry.get_instance') as mock_registry:
           # Setup mock registry with necessary mocks
           mock_registry.return_value.some_dependency = MagicMock()
           
           # Create implementation
           implementation = SomeImplementation()
           
           # Verify the Registry was used
           mock_registry.assert_called_once()
   ```

2. **Circular Import Detection**: Add a pre-commit hook to detect potential circular imports:
   ```bash
   # In pre-commit-config.yaml
   - repo: local
     hooks:
       - id: circular-import-check
         name: Circular Import Check
         entry: python scripts/detect_circular_imports.py
         language: system
         types: [python]
   ```

3. **Implementation Verification**: Ensure each implementation properly follows its interface:
   ```python
   def test_implements_interface():
       """Verify implementation correctly implements the interface."""
       implementation = SomeImplementation()
       # Check that implementation has all interface methods
       for method_name in dir(SomeInterface):
           if not method_name.startswith('_'):
               assert hasattr(implementation, method_name)
   ```