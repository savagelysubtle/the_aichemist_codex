---
description: Guidelines for writing tests and following test-driven development
globs: **/*.py
alwaysApply: true
---
# Testing Guidelines

## 1. Test-Driven Development (TDD) Approach

The AIChemist Codex project follows a test-driven development approach:

1. **Write tests first**: Before implementing a feature, write tests that define the expected behavior
2. **Run tests and see them fail**: Verify that the tests fail before implementation
3. **Implement the feature**: Write the minimum code to make the tests pass
4. **Run tests and see them pass**: Verify that the implementation works
5. **Refactor**: Clean up the code while ensuring tests still pass

## 2. Test Directory Structure

Tests should mirror the structure of the main codebase:

```
tests/
├── unit/                     # Unit tests
│   ├── backend/
│   │   ├── core/
│   │   ├── infrastructure/
│   │   └── domain/
├── integration/              # Integration tests
│   ├── backend/
└── fixtures/                 # Test fixtures
```

## 3. Writing Unit Tests

Unit tests should be focused on testing individual components in isolation:

```python
import pytest
from unittest.mock import MagicMock, patch

from src.the_aichemist_codex.backend.domain.file_reader.file_reader import FileReaderImpl

class TestFileReader:
    def setup_method(self):
        # Setup mocks
        self.registry_mock = MagicMock()
        self.file_validator_mock = MagicMock()
        self.async_io_mock = MagicMock()

        # Setup registry mocks
        self.registry_mock.file_validator = self.file_validator_mock
        self.registry_mock.async_io = self.async_io_mock

    @patch('src.the_aichemist_codex.registry.Registry.get_instance')
    def test_read_text(self, mock_registry):
        # Arrange
        mock_registry.return_value = self.registry_mock
        self.async_io_mock.read_file.return_value = "file content"
        file_reader = FileReaderImpl()

        # Act
        result = file_reader.read_text("test.txt")

        # Assert
        assert result == "file content"
        self.file_validator_mock.validate_path.assert_called_once_with("test.txt")
        self.async_io_mock.read_file.assert_called_once_with("test.txt")
```

## 4. Test Naming Conventions

- Test files should be named `test_*.py`
- Test classes should be named `Test*`
- Test methods should be named `test_*`
- Test method names should be descriptive, following the pattern `test_<method_name>_<scenario>_<expected_result>`

Examples:
- `test_read_text_valid_file_returns_content`
- `test_read_text_file_not_found_raises_exception`

## 5. Using Fixtures

Use pytest fixtures for common setup:

```python
@pytest.fixture
def mock_registry():
    registry_mock = MagicMock()
    registry_mock.file_validator = MagicMock()
    registry_mock.async_io = MagicMock()

    with patch('src.the_aichemist_codex.registry.Registry.get_instance', return_value=registry_mock):
        yield registry_mock

def test_read_text(mock_registry):
    # Test using the mock_registry fixture
    file_reader = FileReaderImpl()
    # ...
```

## 6. Test Coverage

Aim for high test coverage:
- 90%+ for core functionality
- 80%+ for infrastructure code
- 70%+ for utilities

Use the coverage tool to measure test coverage:

```bash
pytest --cov=src.the_aichemist_codex tests/
```

## 7. Error Testing

Always test error cases:

```python
def test_read_text_file_not_found_raises_exception(mock_registry):
    # Arrange
    mock_registry.async_io.read_file.side_effect = FileError("File not found")
    file_reader = FileReaderImpl()

    # Act & Assert
    with pytest.raises(FileError, match="File not found"):
        file_reader.read_text("nonexistent.txt")
```

## 8. Testing the Registry

When testing with the Registry pattern:

1. **Mock the Registry**: Patch `Registry.get_instance()` to return a mock
2. **Configure the mock**: Set up the mock registry to return other mocks for its properties
3. **Test interactions**: Verify that your code interacts with the registry correctly

## 9. Integration Tests

Integration tests should verify that components work together:

```python
@pytest.mark.integration
def test_file_reader_with_real_io():
    # Bootstrap the application with real components
    from src.the_aichemist_codex.bootstrap import bootstrap
    bootstrap()

    from src.the_aichemist_codex.registry import Registry
    registry = Registry.get_instance()

    # Create a test file
    test_file = "test_file.txt"
    with open(test_file, "w") as f:
        f.write("test content")

    try:
        # Test with real components
        file_reader = registry.file_reader
        content = file_reader.read_text(test_file)

        assert content == "test content"
    finally:
        # Clean up
        import os
        if os.path.exists(test_file):
            os.remove(test_file)
```

## 10. Testing Exception Handling

Always test that your code handles exceptions correctly:

```python
def test_handle_file_error():
    # Arrange
    mock_registry = MagicMock()
    mock_registry.async_io.read_file.side_effect = FileError("File not found")

    with patch('src.the_aichemist_codex.registry.Registry.get_instance', return_value=mock_registry):
        file_reader = FileReaderImpl()

        # Act & Assert
        with pytest.raises(FileError) as excinfo:
            file_reader.read_text("test.txt")

        assert "File not found" in str(excinfo.value)
```

## 11. Mock Best Practices

1. **Mock at the right level**: Mock dependencies, not the system under test
2. **Verify interactions**: Use `assert_called_with()` to verify that dependencies are called correctly
3. **Return realistic data**: Mocks should return data that resembles what the real dependency would return
4. **Test edge cases**: Use mocks to simulate error conditions and edge cases